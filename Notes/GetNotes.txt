                                        *Git*

Why Do We Need Version Control?
Version Control lets us look at older versions of the code and lets us roll back our code if we make mistakes.

Distributed Version Control Systems and Centralized Version Control Systems.

Centralized Version Control.
You must stay connected to the server to see the history of your app and to commit changes to the server.
Branching is also more expensive in Centralized Version Control (branching is working sepertatly so you don't conflict with anyone else).
Branching has to create a complete copy of the code to branch and that is expensive.

Some Centralized Version Control Systems also use Pessimistic locking so that if multiple people touch the same file only the first person can actually do stuff with while everyone after is given an error.
If someone doesn't check the file back in then nobody has access to the file until the file is checked back in or someone overrides the lock.

Distributed Version Control.
You need a connection to the server to first retrieve the source code but if you are disconnected you can still make commits and the commit can be pushed up after you reconnect.
You also get the history with your first retrievel of the source code so you can look at the history even if you are disconnected from the server.
Branching is also cheaper in Distributed Version Control because it uses a pointer.
Do keep in mind if your computer loses the data before you can push it to the server your commits will not be saved.

Git is a Distributed Control System.

                                            Git Commands have a *C next to them.

git init will create a Git repository. *C
.git folder (the repository) is were your database lives for keeping track of what changes you made and your code repository.

NOTE For VS code you can actually use ctr ` to open the terminal.

git status will tell you the state of your repository and if you have any commits. *C
You will use git status quite often.

git add fileName will add your file to a git commit meaning that you can then save the file to git. *C
Then use git commit -m "yourTextForTheCommit" to actually make a commit with the files you added. *C



Working Directory is your untracked changes.
Add moves your file to the Staging Area.
Commiting then moves the file to the Local Repository.

git log will show you the git history or your commits. *C

Next to each commit in the history is a unique value that is a SHA-1 hash of your commit.
If you ever need to reference this specific commit you can use the hash value because the hash will always be unique.

git log --oneline will give you a shorter hash and put all of the history on just 1 line. *C

git add . will add everything in the current directory and down. C*

git add -A will add everything. c*

git reset Head~1 will undo the last commit you did. You can change the number after ~ to say how many commits to undo. C*
IF you do this you will need to run the add again the entire commit is now gone.